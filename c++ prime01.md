## c++ prime01

### 字符和字符串字面值

字符串字面值的实际类型类型是由常量字符构成的数组

编译器在每个字符串的末尾添加一个空字符（‘\0'）

```c
char c = 'a';  //只有一个字符a
char ca = "hello";  //表示hello+\0

```

### 变量

变量的初始化和赋值不是一样，初始化不是赋值，初始化的含义是创建变量的同时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新的值来代替。

```c
int a =10;  //初始化
a = 30;  //赋值
```

默认初始化

如果变量定义时没有指定初值，变量被默认初始化，默认值是多少由变量的类型决定。

变量声明和定义的关系：

​	声明规定了变量的类型和名字，定义除了上述操作外，还为变量申请了存储空间，也可能会为变量赋一个初值。

如果想声明而非定义，可以用extern关键字

```c
extern int i;  //声明
int j;  //声明并定义
extern double pi = 3.1416;  //定义
```

**变量只能被定义一次，但是可以被声明多次**

**引用只能绑定在对象上，不能与字面值或者某个表达式的计算结果绑定，必须初始化**

```c++
int i=10;
int &b = i;//引用，起别名
int &c;  //错误，必须初始化
int &d=10;  //错误，不能和字面值绑定
```

#### void*指针

这是一类特殊的指针，用于存放任何对象的地址，但是不能直接操作void*指针所指的对象，因为不知道他是什么类型。

#### 指向指针的指针

```c++
//指向指针的指针
#include<iostream>
using namespace std;

int main()
{
	int a = 10;
	int* p = &a;  //P指向a，存的是a的地址
	int** q = &p;  //q指向p，存的是q的地址,是指向指针的指针

	//输出a的三种方法
	cout << "a=" << a << endl;  //10
	cout << "a = " << *p << endl;  //10
	cout << "a= " << **q << endl;  //10

	system("pause");
	return 0;
}
```

#### 指向指针的引用

引用本身不是一个对象，因此不能定义指向引用的指针，但是指针是对象，所以存在对指针的引用

```c++
//指向指针的引用
#include<iostream>
using namespace std;

int main()
{
	int a = 10;
	int b = 20;
	int* p = &a;  //定义了一个指针指向变量a，p存放的是a的地址

	int*& r = p;  //指向指针的引用，相当于给指针p起了一个别名r,从右往左看，&离r最近，确定r是一个引用，在看其他部分，表示是一个指向指针的引用
	r = &b;  //将r指向b，相当于将p指向b

	//输出此时p所指变量的值
	cout << "p所致变量的值为：" << *p << endl;  //20

	system("pause");

	return 0;
}
```

**如果想在多个文件之间共享const对象，必须在变量的定义之前添加extern关键字**

#### constexpr变量

一般来说，如果认定某个变量是一个常量表达式，就可以声明为constexpr

```c
constexpr int mf=20;  //20是常量表达式
```

#### auto类型说明符

让编译器替我们分析表达式所属的类型

```c
auto item = val1 + val2;  //item 初始化为val1 + val2的结果
```

auto声明的类型必须保持一致

```c
auto i=0,*p=&i;  //正确，因为i是整型，p是指向整型的指针
auto sz=0,pi=3.14;   //错误，sz和pi的类型不一样
```

## 字符串、向量和数组

vector对象（以及string对象）的下标运算符可用于访问已经存在的元素，而不能用于添加元素，只能用push_back;

#### 迭代器

类似于指针类型，提供了对对象的间接访问，就迭代器而言，其对象是容器中的元素或者string对象中的字符

如果容器为空，begin和end返回的是同一个迭代器，都是尾后迭代器